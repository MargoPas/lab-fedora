	1) Что происходит при прерывании скрипта `text-trap.sh`? Объясните, почему.
При вызове скрипта `text-trap.sh` начинают выводится цифры 1, 2, 3, ... через каждую секунду (это прописано в цикле)
После вызова сигнала прерывания `Ctrl+C` или иначе `SIGINT` мы переходим в trap и там указана обработка данного сигнала ля данного скрипта, там написана строка, которую необходимо вывесты при прерывании работы скрипта.Эту строка и выведется в терминале при нажатии `Ctrl+C`.  
	2) Напишите, по какой причине выводы команды `ls -l /proc/self` и `ls -l /proc/$$` отличаются?
Потому что `/proc/$$/task` - это задача шелла, а `/proc/self/task` - это задача ls.  
	3) Напишите, какие дескрипторы в выводе команды `ls -l /proc/self/fd` отвечают за `stdin, stdout, stderr`.

 ` итого 0`  
  `lrwx------. 1 rita rita 64 дек  4 10:57 0 -> /dev/pts/0 	для ввода`  
`  lrwx------. 1 rita rita 64 дек  4 10:57 1 -> /dev/pts/0	для вывода`  
`  lrwx------. 1 rita rita 64 дек  4 10:57 2 -> /dev/pts/0 	для ошибок`  

	4) Что происходит с дескрипторами при перенаправлении потоков `stdout` и `stderr` в файлы при выполнении команды `ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err`?

`итого 0  `  
`l-wx------ 1 rita rita 64 дек  4 11:02 0 -> /dev/pts/0`  	
`l-wx------ 1 rita rita 64 дек  4 11:02 1 -> /tmp/ls.out	дескриптор изменился, теперь вывод направлен в файл`  
`l-wx------ 1 rita rita 64 дек  4 11:02 2 -> /tmp/ls.err	дескриптор изменился, теперь вывод ошибокнаправлен в файл`  

	5) Запишите эту же команду, добавив к ней перенаправление потока `stdin`. Что изменилось?

Команда:
`ls -l /proc/self/fd > /tmp/ls.out 2> /tmp/ls.err 0</tmp/ls.in`

при выводе файла ls.out получаем:
`итого 0`  
`lr-x------. 1 rita rita 64 дек  4 11:03 0 -> /tmp/ls.in 	изменился ввод, теперь он из файла ls.in`  
`l-wx------. 1 rita rita 64 дек  4 11:03 1 -> /tmp/ls.out`  
`l-wx------. 1 rita rita 64 дек  4 11:03 2 -> /tmp/ls.err`  

	6) Какой эффект наблюдается при выполнении команды `exec ps -l`?
	
Команда exec заменяет процесс в котором запущена ( то есть когда мы вызвали дочерний sh, то мы его видели, потом exec заменил его полностью, а птоом просто вернул нам выполнение в изначальном варианте, до вызова дочернего sh)  
	7) Что означает pos при выводе содержимого файла `/proc/$$/fdinfo/3`?
pos означает номер сивола на котором сейчас установлен current file offset (укзатель read//write). При выполнении указанной в лбораторной работе команды:
`echo Test3 >&3`  
`echo Test333 >&3`  
`cat /proc/3203/fdinfo/3 `  

мы увидим, что pos:	14, то есть test3 это 5 символов, test333 - это 7 символов, и еще два символа на перевод каретки на новую строку. получается: 5+7+2 = 14.  
	8) Существует ли возможность читать содержимое файла test.out даже после его удаления? Почему так происходит?
	
Да, возможно.(роверено в лабораторной)
На лекции нам сказали, что по сути, когд процесс создается, у него появляется процесс потомок, куда используемый файл и копируется. При удалении с помощью команды rm мы удаляем ссылку на inode данного файла, однако в процессе потомке хранится копия и ссылка на необходимый inode. Поэтому обращаясь к удаленному файлу мы образаемся по ссылке, которая осталась у проуесса потомка (надеюь я правильно это осознала на лекции)
